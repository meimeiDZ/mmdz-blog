# 算法的时间与空间复杂度

> **吐槽：** 作为一个Java程序员，说实话，目前为止项目中还没有使用到【算法】这种级别的东西。
>
> 衡量不同算法之间的优劣，主要还是从算法所占用的「时间」和「空间」两个维度去考量。
>
> - **时间维度**：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。
> - **空间维度**：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。
>
> 因此，评价一个算法的效率主要是看它的时间复杂度和空间复杂度情况。然而，有的时候时间和空间却又是「鱼和熊掌」，不可兼得的，那么我们就需要从中去取一个平衡点。
>
> 下面我来分别介绍一下「时间复杂度」和「空间复杂度」的计算方式。

------

## 1.时间复杂度

?>`是一个定性的描述算法运行时间的函数`；是代表算法输入值的字符串的长度的函数（该句来自wiki pedia）

**常见的时间复杂度量级有：**

> - 常数阶O(1)
> - 对数阶O(logN)
> - 线性阶O(n)
> - 线性对数阶O(nlogN)
> - 平方阶O(n²)
> - 立方阶O(n³)
> - K次方阶O(n^k)
> - 指数阶(2^n)
>
> 上面从上至下依次的时间复杂度越来越大，执行的效率越来越低。

<!-- tabs:start -->

#### **常数阶O(1)**

无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如：

```java
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```

上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。

#### **对数阶O(logN)**

还是先来看代码：

```java
int i = 1;
while(i<n){
    i = i * 2;
}
```

从上面代码可以看到，在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。我们试着求解一下，假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2^n
也就是说当循环 log2^n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：**O(logN)**

#### **线性阶O(n)**

这个在最开始的代码示例中就讲解过了，如：

```java
for(i=1; i<=n; ++i){
   j = i;
   j++;
}
```

这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度。

#### **线性对数阶O(nlogN)**

线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)。

就拿上面的代码加一点修改来举例：

```java
for(m=1; m<n; m++){
    i = 1;
    while(i<n){
        i = i * 2;
    }
}
```

#### **平方阶O(n²)**

平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。
举例：

```java
for(x=1; i<=n; x++){
   for(i=1; i<=n; i++){
       j = i;
       j++;
    }
}
```

这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n*n)，即 O(n²)
如果将其中一层循环的n改成m，即：

```java
for(x=1; i<=m; x++){
   for(i=1; i<=n; i++){
       j = i;
       j++;
    }
}
```

那它的时间复杂度就变成了 O(m*n)

<!-- tabs:end -->

------

## 2.空间复杂度

?>是对一个算法在运行过程中`临时占用存储空间大小的度量`，即问题规模n的函数。

**空间复杂度比较常用的有：**

> - O(1)
> - O(n)
> - O(n²)

<!-- tabs:start -->

#### **空间复杂度 O(1)**

如果算法执行**所需要的临时空间不随着某个变量n的大小而变化**，即此算法空间复杂度为一个常量，可表示为 O(1)
举例：

```java
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```

代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1)

#### **空间复杂度 O(n)**

我们先看一个代码：

```java
int[] m = new int[n]
for(i=1; i<=n; ++i){
   j = i;
   j++;
}
```

这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)

<!-- tabs:end -->
